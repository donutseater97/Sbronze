import streamlit as st
import pandas as pd
from datetime import date, datetime
import os
import plotly.express as px
import plotly.graph_objects as go
import yfinance as yf
import warnings
import subprocess
import sys
import base64
import requests

# ---------- AUTHENTICATION ----------
OWNER_PASSWORD = "123"

if "authenticated" not in st.session_state:
    st.session_state.authenticated = False

# ---------- APP SETUP ----------
st.set_page_config(page_title="Sbronze Treasure Hunt", layout="wide")
st.title("ðŸ“Š Sbronze Treasure Hunt")

FUNDS_FILE = "funds.csv"
TRANSACTIONS_FILE = "transaction_history.csv"

# ---------- COLOR MAPPING ----------
FUND_COLORS = {}

# ---------- LOAD DATA ----------
def load_data():
    if os.path.exists(FUNDS_FILE):
        funds = pd.read_csv(FUNDS_FILE)
    else:
        funds = pd.DataFrame(columns=["Fund", "Ticker", "ISIN", "Fund Name", "Type", "Colour"])

    if os.path.exists(TRANSACTIONS_FILE):
        transactions = pd.read_csv(TRANSACTIONS_FILE, parse_dates=["Date"])
    else:
        transactions = pd.DataFrame(columns=["Date", "Fund", "Price (â‚¬)", "Quantity", "Fees (â‚¬)"])

    return funds, transactions

funds, transactions = load_data()

# Build FUND_COLORS and HISTORICAL_FUND_MAPPING from funds data
for _, row in funds.iterrows():
    FUND_COLORS[row["Fund"]] = row["Colour"]

# Build Yahoo Finance tickers list (ticker + .F)
yahoo_tickers = [f"{t}.F" for t in funds["Ticker"].dropna().unique()]

# ---------- GITHUB COMMIT HELPERS ----------

def _get_secret(name: str, default: str | None = None) -> str | None:
    try:
        return st.secrets.get(name, os.environ.get(name, default))
    except Exception:
        return os.environ.get(name, default)

GITHUB_TOKEN = _get_secret("GITHUB_TOKEN")
GITHUB_REPO = _get_secret("GITHUB_REPO", "donutseater97/Sbronze")
GITHUB_BRANCH = _get_secret("GITHUB_BRANCH", "main")

def github_get_file_sha(path: str) -> str | None:
    if not GITHUB_TOKEN or not GITHUB_REPO:
        return None
    url = f"https://api.github.com/repos/{GITHUB_REPO}/contents/{path}"
    params = {"ref": GITHUB_BRANCH}
    headers = {"Authorization": f"Bearer {GITHUB_TOKEN}", "Accept": "application/vnd.github+json"}
    r = requests.get(url, headers=headers, params=params, timeout=30)
    if r.status_code == 200:
        return r.json().get("sha")
    return None

def github_put_file(path: str, content_str: str, message: str) -> bool:
    if not GITHUB_TOKEN or not GITHUB_REPO:
        return False
    url = f"https://api.github.com/repos/{GITHUB_REPO}/contents/{path}"
    headers = {"Authorization": f"Bearer {GITHUB_TOKEN}", "Accept": "application/vnd.github+json"}
    sha = github_get_file_sha(path)
    data = {
        "message": message,
        "content": base64.b64encode(content_str.encode("utf-8")).decode("ascii"),
        "branch": GITHUB_BRANCH,
    }
    if sha:
        data["sha"] = sha
    r = requests.put(url, headers=headers, json=data, timeout=30)
    return 200 <= r.status_code < 300

# ---------- HISTORICAL PRICES DATA FETCHING (CSV cache) ----------

def load_historical_prices():
    """Load pre-generated historical_data.csv (investgo data) committed to the repo."""
    if not os.path.exists("historical_data.csv"):
        st.error("historical_data.csv not found. It is generated by GitHub Actions or by running get_historical_data.py locally.")
        return pd.DataFrame()

    try:
        df = pd.read_csv("historical_data.csv")
    except Exception as exc:  # pragma: no cover
        st.error(f"Could not read historical_data.csv: {exc}")
        return pd.DataFrame()

    # Normalize column names for UI
    if "Date" in df.columns:
        df = df.rename(columns={"Date": "date"})

    # Date column is already tz-naive from get_historical_data.py (converted to Europe/Rome)
    if "date" in df.columns:
        df["date"] = pd.to_datetime(df["date"], errors="coerce")

    # Map ticker columns to fund names (e.g., 0P0001CRXW.F -> US)
    for _, row in funds.iterrows():
        ticker = row["Ticker"]
        fund_name = row["Fund"]
        yahoo_col = f"{ticker}.F"
        if yahoo_col in df.columns:
            df = df.rename(columns={yahoo_col: fund_name})

    return df




# ---------- SIDEBAR NAVIGATION ----------
def overview_and_charts():
    # ---------- PORTFOLIO SUMMARY ----------
    st.header("ðŸ“ˆ Portfolio Summary")
    
    # Fund filter buttons
    if "portfolio_fund_filter" not in st.session_state:
        st.session_state.portfolio_fund_filter = funds["Fund"].tolist() if len(funds) > 0 else []
    
    if len(funds) > 0:
        st.markdown("**Filter by Fund:**")
        
        # Generate custom CSS for fund buttons
        fund_button_css = "<style>"
        for fund in funds["Fund"].tolist():
            hex_color = FUND_COLORS.get(fund, "#999999")
            # Convert hex to rgb
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            fund_button_css += f"""
            button[data-testid="baseButton-primary"][aria-label="{fund}"] {{
                background-color: rgba(200, 200, 200, 0.8) !important;
                border: none !important;
                color: rgb({r}, {g}, {b}) !important;
                font-weight: 600 !important;
            }}
            """
        fund_button_css += "</style>"
        st.markdown(fund_button_css, unsafe_allow_html=True)
        
        # Create columns for all buttons (fund buttons + reset button)
        num_cols = len(funds["Fund"].tolist()) + 1
        cols = st.columns(num_cols)
        
        for idx, fund in enumerate(funds["Fund"].tolist()):
            with cols[idx]:
                is_active = fund in st.session_state.portfolio_fund_filter
                hex_color = FUND_COLORS.get(fund, "#999999")
                if st.button(fund, key=f"portfolio_btn_{fund}", type="primary" if is_active else "secondary", width="stretch"):
                    if is_active:
                        st.session_state.portfolio_fund_filter.remove(fund)
                    else:
                        st.session_state.portfolio_fund_filter.append(fund)
                    st.rerun()
        
        # Reset button in last column
        with cols[-1]:
            if st.button("âœ•", key="reset_portfolio_filters", help="Reset filters", width="stretch"):
                st.session_state.portfolio_fund_filter = funds["Fund"].tolist()
                st.rerun()
        filter_funds = st.session_state.portfolio_fund_filter
    else:
        filter_funds = []
    
    if len(transactions) > 0:
        df = transactions.copy()
        df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
        df = df.dropna(subset=["Date"])
        
        # Apply fund filter
        if filter_funds:
            df = df[df["Fund"].isin(filter_funds)]
        
        # Calculate metrics by fund
        # Calculate Gross Contribution (theor) per fund
        df["Gross Contribution (real)"] = df["Quantity"] * df["Price (â‚¬)"] + df["Fees (â‚¬)"]
        df["Gross Contribution (theor)"] = (df["Gross Contribution (real)"] / 10).round() * 10
        df["Net Invested"] = df["Quantity"] * df["Price (â‚¬)"]
        
        summary = df.groupby("Fund").agg({
            "Quantity": "sum",
            "Fees (â‚¬)": "sum",
            "Gross Contribution (theor)": "sum",
            "Net Invested": "sum"
        }).reset_index()
        
        # Rename columns
        summary = summary.rename(columns={
            "Gross Contribution (theor)": "Gross Contributions (â‚¬)",
            "Net Invested": "Net Invested (â‚¬)"
        })
        summary["Fees (â‚¬)"] = summary["Fees (â‚¬)"]
        
        # Calculate Average NAV
        summary["Average NAV (â‚¬)"] = (summary["Gross Contributions (â‚¬)"] - summary["Fees (â‚¬)"]) / summary["Quantity"]
        
        # Get latest price from historical data
        hist_data = load_historical_prices()
        last_hist_date = (
            pd.to_datetime(hist_data["date"]).max()
            if len(hist_data) > 0 and "date" in hist_data.columns
            else None
        )
        
        # Per-fund decimal precision
        def _count_decimals(num):
            if pd.isna(num):
                return 0
            s = f"{float(num):.6f}".rstrip('0').rstrip('.')
            if '.' in s:
                return min(len(s.split('.')[-1]), 6)
            return 0
        try:
            fund_qty_decimals_overview = (
                transactions.groupby("Fund")["Quantity"].apply(
                    lambda s: max((_count_decimals(v) for v in s if pd.notna(v)), default=0)
                ).to_dict()
            )
        except Exception:
            fund_qty_decimals_overview = {}
        fund_qty_decimals_overview = {f: min(int(d or 0), 3) for f, d in fund_qty_decimals_overview.items()}
        
        # Format Quantity with per-fund precision
        def format_qty_overview(row):
            dp = fund_qty_decimals_overview.get(row["Fund"], 3)
            q = row["Quantity"]
            rounded = round(q, dp)
            if rounded == int(rounded):
                return str(int(rounded))
            return f"{rounded:.{dp}f}".rstrip('0').rstrip('.')
        
        # Store numeric quantity before formatting for calculation (make explicit copy)
        qty_numeric = summary["Quantity"].astype(float).copy()
        
        # Get latest price and calculate Market Value (before formatting Quantity)
        if len(hist_data) > 0 and "date" in hist_data.columns:
            latest_date = pd.to_datetime(hist_data["date"]).max()
            latest_prices = {}
            for fund in summary["Fund"]:
                if fund in hist_data.columns:
                    price_vals = hist_data[hist_data["date"] == latest_date][fund].values
                    if len(price_vals) > 0 and pd.notna(price_vals[0]):
                        latest_prices[fund] = price_vals[0]
            summary["Latest Price (â‚¬)"] = summary["Fund"].map(latest_prices)
            # Calculate Market Value with numeric quantities before formatting
            summary["Market Value (â‚¬)"] = qty_numeric * summary["Latest Price (â‚¬)"].fillna(0.0)
        else:
            summary["Latest Price (â‚¬)"] = 0.0
            summary["Market Value (â‚¬)"] = 0.0
        
        # Now format Quantity for display
        summary["Quantity"] = summary.apply(format_qty_overview, axis=1)
        
        # Calculate Total Return [â‚¬ (%)]
        summary["Total Return (â‚¬)"] = summary["Market Value (â‚¬)"] - summary["Gross Contributions (â‚¬)"]
        summary["Total Return (%)"] = (summary["Total Return (â‚¬)"] / summary["Gross Contributions (â‚¬)"] * 100).round(2)
        summary["Total Return [â‚¬ (%)]"] = summary["Total Return (â‚¬)"].round(2).astype(str) + " (" + summary["Total Return (%)"].astype(str) + "%)"
        
        # Calculate Net Return [â‚¬ (%)]
        summary["Net Return (â‚¬)"] = summary["Market Value (â‚¬)"] - summary["Net Invested (â‚¬)"]
        summary["Net Return (%)"] = (summary["Net Return (â‚¬)"] / summary["Net Invested (â‚¬)"] * 100).round(2)
        summary["Net Return [â‚¬ (%)]"] = summary["Net Return (â‚¬)"].round(2).astype(str) + " (" + summary["Net Return (%)"].astype(str) + "%)"
        
        # Calculate MoM performance (%)
        # Get transactions from last 2 months for each fund
        df["month"] = df["Date"].dt.to_period("M")
        current_month = df["month"].max()
        prev_month = current_month - 1
        
        mom_performance = {}
        for fund in summary["Fund"]:
            fund_df = df[df["Fund"] == fund]
            current_month_price = fund_df[fund_df["month"] == current_month]["Price (â‚¬)"].mean()
            prev_month_price = fund_df[fund_df["month"] == prev_month]["Price (â‚¬)"].mean()
            if pd.notna(prev_month_price) and prev_month_price > 0 and pd.notna(current_month_price):
                mom_performance[fund] = ((current_month_price - prev_month_price) / prev_month_price * 100)
            else:
                mom_performance[fund] = 0.0
        summary["MoM performance (%)"] = summary["Fund"].map(mom_performance).round(2)
        
        # Calculate Weight
        total_market_value = summary["Market Value (â‚¬)"].sum()
        summary["Weight (Mkt Value)"] = (summary["Market Value (â‚¬)"] / total_market_value * 100).round(2)
        
        # Order by funds.csv order
        fund_order = funds["Fund"].tolist()
        summary["fund_order"] = summary["Fund"].map({f: i for i, f in enumerate(fund_order)})
        summary = summary.sort_values("fund_order").reset_index(drop=True)
        
        # Select and format final columns
        # Create display dataframe with selected columns in desired order
        display_summary = summary[[
            "Fund",                          # Fund identifier
            "Gross Contributions (â‚¬)",       # Sum of all investment amounts (quantity Ã— price)
            "Net Invested (â‚¬)",              # Gross contributions plus fees (actual cash outlay)
            "Fees (â‚¬)",                      # Total transaction fees paid
            "Latest Price (â‚¬)",              # Latest price from historical data
            "Average NAV (â‚¬)",               # Average price per unit (gross contributions Ã· quantity)
            "Quantity",                      # Total units/shares held
            "Market Value (â‚¬)",              # Current portfolio value (quantity Ã— latest price)
            "Total Return [â‚¬ (%)]",          # Profit/loss before fees: (market value - gross contributions)
            "Net Return [â‚¬ (%)]",            # Profit/loss after fees: (market value - net invested)
            "MoM performance (%)",           # Month-over-month price change percentage
            "Weight (Mkt Value)"             # Portfolio allocation: (market value Ã· total market value) Ã— 100
        ]].copy()
        
        # Rename Total Return to Return
        display_summary = display_summary.rename(columns={"Total Return [â‚¬ (%)]": "Return [â‚¬ (%)]"})
        
        # Keep raw values for color logic before formatting
        display_summary["_Total_Return_raw"] = summary["Total Return (â‚¬)"]
        display_summary["_Net_Return_raw"] = summary["Net Return (â‚¬)"]
        display_summary["_MoM_raw"] = summary["MoM performance (%)"]
        
        # Format numeric columns
        for col in ["Gross Contributions (â‚¬)", "Net Invested (â‚¬)", "Fees (â‚¬)", "Latest Price (â‚¬)", "Average NAV (â‚¬)", "Market Value (â‚¬)"]:
            display_summary[col] = display_summary[col].apply(lambda x: f"â‚¬ {x:,.2f}")
        
        display_summary["MoM performance (%)"] = display_summary["MoM performance (%)"].apply(lambda x: f"{x:.2f}%")
        display_summary["Weight (Mkt Value)"] = display_summary["Weight (Mkt Value)"].apply(lambda x: f"{x:.2f}%")
        
        # Store raw values for lookup
        raw_values = display_summary[["Fund", "_Total_Return_raw", "_Net_Return_raw", "_MoM_raw"]].set_index("Fund")
        
        # Remove helper columns from display
        display_summary = display_summary.drop(columns=["_Total_Return_raw", "_Net_Return_raw", "_MoM_raw"])
        
        # Apply color coding
        def style_fund_rows(row):
            fund_name = row["Fund"]
            hex_color = FUND_COLORS.get(fund_name, "#000000")
            # Convert hex to rgba with light alpha
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            rgba = f"rgba({int(hex_color[0:2], 16)}, {int(hex_color[2:4], 16)}, {int(hex_color[4:6], 16)}, 0.15)"
            
            # Get raw values for this fund
            total_return_raw = raw_values.loc[fund_name, "_Total_Return_raw"]
            net_return_raw = raw_values.loc[fund_name, "_Net_Return_raw"]
            mom_raw = raw_values.loc[fund_name, "_MoM_raw"]
            
            styles = []
            for col in row.index:
                if col == "Fund":
                    styles.append("background-color: " + rgba)
                elif col == "Return [â‚¬ (%)]":
                    bg_color = "background-color: rgba(46, 160, 67, 0.15);" if total_return_raw >= 0 else "background-color: rgba(248, 81, 73, 0.15);"
                    styles.append(bg_color)
                elif col == "Net Return [â‚¬ (%)]":
                    bg_color = "background-color: rgba(46, 160, 67, 0.15);" if net_return_raw >= 0 else "background-color: rgba(248, 81, 73, 0.15);"
                    styles.append(bg_color)
                elif col == "MoM performance (%)":
                    bg_color = "background-color: rgba(46, 160, 67, 0.15);" if mom_raw >= 0 else "background-color: rgba(248, 81, 73, 0.15);"
                    styles.append(bg_color)
                else:
                    styles.append("")
            return styles
        
        styled_summary = display_summary.style.apply(style_fund_rows, axis=1)
        st.dataframe(styled_summary, width="stretch", hide_index=False)
        
        # Totals row
        st.markdown("")
        last_date_label = last_hist_date.strftime("%Y-%m-%d") if last_hist_date is not None and pd.notna(last_hist_date) else "-"
        st.markdown(f"**Totals based on filters (as of {last_date_label}):**")
        total_gross = summary["Gross Contributions (â‚¬)"].sum()
        total_fees = summary["Fees (â‚¬)"].sum()
        total_net = summary["Net Invested (â‚¬)"].sum()
        total_quantity = summary["Quantity"].sum()
        total_return = summary["Total Return (â‚¬)"].sum()
        total_net_return = summary["Net Return (â‚¬)"].sum()
        
        # Calculate percentages
        total_return_pct = (total_return / total_gross * 100) if total_gross > 0 else 0
        total_net_return_pct = (total_net_return / total_net * 100) if total_net > 0 else 0
        total_fees_pct = (total_fees / total_gross * 100) if total_gross > 0 else 0
        
        # Totals order: Return, Net Return, Fees, Gross Contributions, Market Value, Net Invested
        row1_col1, row1_col2, row1_col3 = st.columns(3)
        with row1_col1:
            st.metric(
                "Total Return",
                f"â‚¬ {total_return:,.2f}",
                delta=f"{total_return_pct:+.2f}%",
                delta_color="normal",
            )
        with row1_col2:
            st.metric(
                "Total Net Return",
                f"â‚¬ {total_net_return:,.2f}",
                delta=f"{total_net_return_pct:+.2f}%",
                delta_color="normal",
            )
        with row1_col3:
            st.metric(
                "Total Fees",
                f"â‚¬ {total_fees:,.2f}",
                delta=f"{total_fees_pct:.2f}%",
                delta_color="off",
            )

        row2_col1, row2_col2, row2_col3 = st.columns(3)
        with row2_col1:
            st.metric("Total Gross Contributions", f"â‚¬ {total_gross:,.2f}")
        with row2_col2:
            st.metric("Total Market Value", f"â‚¬ {total_market_value:,.2f}")
        with row2_col3:
            st.metric("Total Net Invested", f"â‚¬ {total_net:,.2f}")
    else:
        st.info("No transactions yet")

    # ---------- CHARTS ----------
    st.divider()
    st.header("ðŸ“Š Charts")
    if len(transactions) > 0:
        df = transactions.copy()
        df["invested"] = df["Quantity"] * df["Price (â‚¬)"] + df["Fees (â‚¬)"]

        df["date_dt"] = pd.to_datetime(df["Date"], errors="coerce")
        df = df.dropna(subset=["date_dt"])  
        if len(df) > 0:
            # Build cumulative Gross Contribution (theor) and market value evolution
            df_sorted = df.sort_values("date_dt")
            df_sorted["Gross Contribution (real)"] = df_sorted["Quantity"] * df_sorted["Price (â‚¬)"] + df_sorted["Fees (â‚¬)"]
            df_sorted["Gross Contribution (theor)"] = (df_sorted["Gross Contribution (real)"] / 10).round() * 10
            
            # Get daily cumulative for all funds combined using (theor) values
            daily_data = df_sorted.groupby("date_dt").agg({
                "Gross Contribution (theor)": "sum"
            }).reset_index()
            daily_data["Gross Contribution"] = daily_data["Gross Contribution (theor)"].cumsum()
            daily_data = daily_data.sort_values("date_dt")
            
            # Create stair-step data: add points before and after each contribution to create flat line effect
            stair_dates = []
            stair_values = []
            for idx, row in daily_data.iterrows():
                if idx > 0:
                    # Add point just before this contribution (at previous value)
                    prev_value = daily_data.iloc[idx - 1]["Gross Contribution"]
                    stair_dates.append(row["date_dt"])
                    stair_values.append(prev_value)
                # Add point at contribution
                stair_dates.append(row["date_dt"])
                stair_values.append(row["Gross Contribution"])
            
            stair_df = pd.DataFrame({"date_dt": stair_dates, "Gross Contribution": stair_values})
            
            # Calculate market value over time (requires historical data)
            hist_data = load_historical_prices()
            market_value_by_date = []
            if len(hist_data) > 0 and "date" in hist_data.columns:
                # Get unique dates from historical data (closest available prices)
                hist_dates = sorted(hist_data["date"].unique())
                
                for hist_date in hist_dates:
                    # Get all transactions up to this historical date
                    tx_up_to_date = df_sorted[df_sorted["date_dt"] <= hist_date]
                    if len(tx_up_to_date) == 0:
                        continue
                    
                    # Get market value as of that historical date
                    mv = 0.0
                    for fund in tx_up_to_date["Fund"].unique():
                        fund_tx = tx_up_to_date[tx_up_to_date["Fund"] == fund]
                        qty = fund_tx["Quantity"].sum()
                        
                        # Get price on exact hist_date
                        if fund in hist_data.columns:
                            price_row = hist_data[hist_data["date"] == hist_date][fund]
                            if len(price_row) > 0 and pd.notna(price_row.iloc[0]):
                                price = price_row.iloc[0]
                                mv += qty * price
                    
                    if mv > 0:
                        market_value_by_date.append({"date": hist_date, "market_value": mv})
            
            market_value_df = pd.DataFrame(market_value_by_date) if market_value_by_date else pd.DataFrame()
            
            # Create side-by-side layout
            col_pie, col_evolution = st.columns([1, 1.2])
            
            with col_pie:
                st.subheader("ðŸ’° Allocation")
                alloc_by = st.selectbox("Group by:", ["Fund", "Type"], key="alloc_selectbox")
                
                if alloc_by == "Fund":
                    alloc = df.groupby("Fund")["invested"].sum().reset_index()
                    alloc = alloc.sort_values("invested", ascending=False)
                    alloc.columns = ["Category", "Value"]
                    color_map = {cat: FUND_COLORS.get(cat, "#999999") for cat in alloc["Category"]}
                else:  # Type
                    alloc = df.merge(funds[["Fund", "Type"]], on="Fund", how="left")
                    alloc = alloc.groupby("Type")["invested"].sum().reset_index()
                    alloc = alloc.sort_values("invested", ascending=False)
                    alloc.columns = ["Category", "Value"]
                    color_map = {
                        "Bond": "#1f77b4", "Equity": "#ff7f0e", "Mixed": "#2ca02c", 
                        "Commodity": "#d62728", "Alternative": "#9467bd", "Other": "#8c564b"
                    }
                
                fig_alloc = go.Figure(data=[go.Pie(
                    labels=alloc["Category"],
                    values=alloc["Value"],
                    hole=0.4,
                    marker=dict(colors=[color_map.get(cat, "#999999") for cat in alloc["Category"]]),
                    hovertemplate="<b>%{label}</b><br>â‚¬%{value:,.2f}<br>%{percent}<extra></extra>"
                )])
                fig_alloc.update_layout(height=450, showlegend=False, hovermode="closest")
                st.plotly_chart(fig_alloc, use_container_width=True)

                # Legend centered below the allocation chart
                legend_row_style = "display:flex; justify-content:center; flex-wrap:nowrap; gap:16px; align-items:center; overflow-x:auto; padding:6px 0; border-top:1px solid rgba(150,150,150,.2);"
                alloc_legend = f"<div style='{legend_row_style}'>" + "".join([
                    f"<div><span style='display:inline-block;width:12px;height:12px;border-radius:2px;background:{color_map.get(cat, '#999999')};border:1px solid rgba(0,0,0,.35);margin-right:6px;vertical-align:middle;'></span>{cat}</div>"
                    for cat in alloc["Category"]
                ]) + "</div>"
                st.markdown(alloc_legend, unsafe_allow_html=True)
            
            with col_evolution:
                st.subheader("ðŸ“ˆ Investment Evolution")
                fig_evolution = go.Figure()
                
                # Stair-step gross contribution with always-visible hover
                fig_evolution.add_trace(go.Scatter(
                    x=stair_df["date_dt"],
                    y=stair_df["Gross Contribution"],
                    mode="lines",
                    name="Gross Contribution",
                    line=dict(color="#667eea", width=2.5),
                    hovertemplate="<b>%{x|%Y-%m-%d}</b><br>â‚¬%{y:,.2f}<extra></extra>",
                    fill="tozeroy",
                    fillcolor="rgba(102, 126, 234, 0.1)",
                ))
                
                # Market value overlay
                if len(market_value_df) > 0:
                    fig_evolution.add_trace(go.Scatter(
                        x=market_value_df["date"],
                        y=market_value_df["market_value"],
                        mode="lines",
                        name="Market Value",
                        line=dict(color="#f093fb", width=2.5),
                        hovertemplate="<b>%{x|%Y-%m-%d}</b><br>â‚¬%{y:,.2f}<extra></extra>",
                    ))
                
                fig_evolution.update_layout(
                    height=520,
                    hovermode="x unified",
                    xaxis_title="",
                    yaxis_title="Value (â‚¬)",
                    template="plotly_white",
                    showlegend=False,
                    dragmode="pan",
                    uirevision="overview_evolution",
                    newshape=dict(line_color="#888888"),
                )
                fig_evolution.update_xaxes(
                    rangeslider=dict(visible=True, thickness=0.07),
                    rangeselector=dict(
                        buttons=[
                            dict(count=1, label="1M", step="month", stepmode="backward"),
                            dict(count=3, label="3M", step="month", stepmode="backward"),
                            dict(count=6, label="6M", step="month", stepmode="backward"),
                            dict(count=1, label="YTD", step="year", stepmode="todate"),
                            dict(count=1, label="1Y", step="year", stepmode="backward"),
                            dict(step="all", label="All"),
                        ]
                    ),
                    showspikes=True,
                    spikemode="across",
                    spikesnap="cursor",
                    spikethickness=1,
                    spikecolor="#888888",
                )
                fig_evolution.update_yaxes(
                    autorange=True,
                    rangemode="normal",
                    fixedrange=False,
                    showspikes=True,
                    spikemode="across",
                )
                
                st.plotly_chart(
                    fig_evolution,
                    use_container_width=True,
                    config=dict(
                        scrollZoom=True,
                        displaylogo=False,
                        doubleClick="reset",
                        modeBarButtonsToAdd=[
                            "drawline",
                            "eraseshape",
                            "zoom2d",
                            "pan2d",
                            "select2d",
                            "lasso2d",
                        ],
                        toImageButtonOptions=dict(format="png", filename="investment_evolution", height=600, width=1200, scale=2),
                    ),
                )
                # Legend centered below the investment evolution chart
                legend_row_style = "display:flex; justify-content:center; flex-wrap:nowrap; gap:16px; align-items:center; overflow-x:auto; padding:6px 0; border-top:1px solid rgba(150,150,150,.2);"
                evo_legend = (
                    f"<div style='{legend_row_style}'>"
                    f"<div><span style='display:inline-block;width:28px;height:0;border-top:3px solid #667eea;vertical-align:middle;margin-right:6px;'></span>Gross Contribution</div>"
                    f"<div><span style='display:inline-block;width:28px;height:0;border-top:3px solid #f093fb;vertical-align:middle;margin-right:6px;'></span>Market Value</div>"
                    f"</div>"
                )
                st.markdown(evo_legend, unsafe_allow_html=True)
        else:
            st.info("No valid dates for investment evolution chart")
    else:
        st.info("No transactions yet")

def transaction_history():
    st.header("ðŸ“œ Transaction History")
    
    # Fund filter buttons
    if "trans_fund_filter" not in st.session_state:
        st.session_state.trans_fund_filter = funds["Fund"].tolist() if len(funds) > 0 else []
    
    if len(funds) > 0:
        st.markdown("**Filter by Fund:**")
        
        # Generate custom CSS for fund buttons
        fund_button_css = "<style>"
        for fund in funds["Fund"].tolist():
            hex_color = FUND_COLORS.get(fund, "#999999")
            # Convert hex to rgb
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            fund_button_css += f"""
            button[data-testid="baseButton-primary"][aria-label="{fund}"] {{
                background-color: rgba(200, 200, 200, 0.8) !important;
                border: none !important;
                color: rgb({r}, {g}, {b}) !important;
                font-weight: 600 !important;
            }}
            """
        fund_button_css += "</style>"
        st.markdown(fund_button_css, unsafe_allow_html=True)
        
        # Create columns for all buttons (fund buttons + reset button)
        num_cols = len(funds["Fund"].tolist()) + 1
        cols = st.columns(num_cols)
        
        for idx, fund in enumerate(funds["Fund"].tolist()):
            with cols[idx]:
                is_active = fund in st.session_state.trans_fund_filter
                hex_color = FUND_COLORS.get(fund, "#999999")
                if st.button(fund, key=f"trans_btn_{fund}", type="primary" if is_active else "secondary", width="stretch"):
                    if is_active:
                        st.session_state.trans_fund_filter.remove(fund)
                    else:
                        st.session_state.trans_fund_filter.append(fund)
                    st.rerun()
        
        # Reset button in last column
        with cols[-1]:
            if st.button("âœ•", key="reset_trans_filters", help="Reset filters", width="stretch"):
                st.session_state.trans_fund_filter = funds["Fund"].tolist()
                st.rerun()
        filter_funds = st.session_state.trans_fund_filter
    else:
        filter_funds = []
    
    # Date filters
    col1, col2 = st.columns(2)
    with col1:
        if len(transactions) > 0:
            # Get the first registered transaction date (earliest date in transaction history)
            first_trans_date = pd.to_datetime(transactions["Date"]).min().date()
            
            # Initialize session state for start date if not set or if it's before first transaction
            if "trans_start_date" not in st.session_state or st.session_state.trans_start_date < first_trans_date:
                st.session_state.trans_start_date = first_trans_date
            
            start_date = st.date_input("Start Date:", value=st.session_state.trans_start_date, key="trans_start_date_input")
        else:
            start_date = None
    with col2:
        if len(transactions) > 0:
            max_date = pd.to_datetime(transactions["Date"]).max().date()
            end_date = st.date_input("End Date:", value=max_date, key="trans_end_date")
        else:
            end_date = None
    
    # Update start_date from input
    if len(transactions) > 0:
        start_date = st.session_state.trans_start_date_input
    
    if len(transactions) > 0:
        trans_df = transactions.copy()
        trans_df["Date"] = pd.to_datetime(trans_df["Date"], errors="coerce")
        
        # Apply filters
        if filter_funds:
            trans_df = trans_df[trans_df["Fund"].isin(filter_funds)]
        if start_date:
            trans_df = trans_df[trans_df["Date"] >= pd.to_datetime(start_date)]
        if end_date:
            trans_df = trans_df[trans_df["Date"] <= pd.to_datetime(end_date)]
        
        trans_df = trans_df.sort_values("Date", ascending=False)
        
        # Calculate derived fields
        trans_df["Reference Period"] = trans_df["Date"].dt.strftime("%Y %b")
        trans_df["Gross Contribution (real)"] = trans_df["Quantity"] * trans_df["Price (â‚¬)"] + trans_df["Fees (â‚¬)"]
        trans_df["Gross Contribution (theor)"] = (trans_df["Gross Contribution (real)"] / 10).round() * 10
        trans_df["Net Invested"] = trans_df["Quantity"] * trans_df["Price (â‚¬)"]
        trans_df["Î” Net Inv vs Exp"] = trans_df["Net Invested"] - trans_df["Gross Contribution (theor)"] + trans_df["Fees (â‚¬)"]
        trans_df["Quantity (theor)"] = (trans_df["Gross Contribution (theor)"] - trans_df["Fees (â‚¬)"]) / trans_df["Price (â‚¬)"]
        trans_df["Î” Quantity"] = trans_df["Quantity"] - trans_df["Quantity (theor)"]
        trans_df["Date_str"] = trans_df["Date"].dt.strftime("%Y-%m-%d")
        
        # Select and reorder columns for display
        display_df = trans_df[[
            "Reference Period",
            "Date_str",
            "Fund",
            "Price (â‚¬)",
            "Quantity",
            "Fees (â‚¬)",
            "Gross Contribution (theor)",
            "Net Invested",
            "Î” Net Inv vs Exp",
            "Quantity (theor)",
            "Î” Quantity",
        ]].copy()
        display_df.columns = [
            "Reference Period",
            "Date",
            "Fund",
            "Price (â‚¬)",
            "Quantity",
            "Fees (â‚¬)",
            "Gross Contribution",
            "Net Invested",
            "Î” Net Inv vs Exp",
            "Quantity (theor)",
            "Î” Quantity",
        ]
        
        # Determine per-fund decimal precision based on all transactions' Quantity
        def _count_decimals(num):
            if pd.isna(num):
                return 0
            s = f"{float(num):.6f}".rstrip('0').rstrip('.')
            if '.' in s:
                return min(len(s.split('.')[-1]), 6)
            return 0
        try:
            fund_qty_decimals = (
                transactions.groupby("Fund")["Quantity"].apply(
                    lambda s: max((_count_decimals(v) for v in s if pd.notna(v)), default=0)
                ).to_dict()
            )
        except Exception:
            fund_qty_decimals = {}
        # Cap decimals to max 3
        fund_qty_decimals = {f: min(int(d or 0), 3) for f, d in fund_qty_decimals.items()}
        
        # Preserve raw numeric values
        display_df["_delta_net_inv_raw"] = trans_df["Î” Net Inv vs Exp"].values
        display_df["_delta_qty_raw"] = trans_df["Î” Quantity"].values

        # Rounded/display deltas for styling (use same precision as shown)
        def format_delta_net_inv(val):
            if pd.isna(val):
                return None
            rounded = round(val, 2)
            return 0.0 if abs(rounded) < 0.005 else rounded

        def format_delta_qty(row):
            dq = row["_delta_qty_raw"]
            if pd.isna(dq):
                return None
            dp = fund_qty_decimals.get(row["Fund"], 3)
            rounded = round(dq, dp)
            return 0.0 if abs(rounded) < 10 ** (-dp) else rounded

        display_df["_delta_net_inv_disp"] = display_df["_delta_net_inv_raw"].apply(format_delta_net_inv)
        display_df["_delta_qty_disp"] = display_df.apply(format_delta_qty, axis=1)
        
        # Quantity formatting function: max 3 decimals, no trailing zeros
        def format_qty(val):
            if pd.isna(val):
                return ""
            # Round to 3 decimals
            rounded = round(val, 3)
            # Format and remove trailing zeros
            if rounded == int(rounded):
                return str(int(rounded))
            return f"{rounded:.3f}".rstrip('0').rstrip('.')
        
        # Combine Net Invested with delta
        display_df["Net Invested (Î” vs Exp)"] = display_df.apply(
            lambda row: f"{row['Net Invested']:.2f} ({row['_delta_net_inv_raw']:+.2f})" if pd.notna(row['_delta_net_inv_raw']) else f"{row['Net Invested']:.2f}",
            axis=1
        )
        
        # Combine Quantity (theor) with delta - decimals based on fund usage
        def format_qty_calc(row):
            dp = fund_qty_decimals.get(row["Fund"], 3)
            q = row["Quantity (theor)"]
            dq = row["_delta_qty_raw"]
            q_str = "" if pd.isna(q) else f"{round(q, dp):.{dp}f}"
            if pd.notna(dq):
                dq_str = f" ({round(dq, dp):+.{dp}f})"
            else:
                dq_str = ""
            return q_str + dq_str
        display_df["Quantity (theor) (Î” vs Q real)"] = display_df.apply(format_qty_calc, axis=1)
        
        # Format Quantity column with flexible decimals
        display_df["Quantity"] = display_df["Quantity"].apply(format_qty)

        # Drop calculation columns
        display_df = display_df.drop(columns=["Net Invested", "Î” Net Inv vs Exp", "Quantity (theor)", "Î” Quantity"])
        
        # Add fund column for styling
        display_df["_fund_type"] = trans_df["Fund"].values
        
        # Create styled dataframe with hue for Fund and deltas
        def style_fund_rows(row):
            fund_type = row["_fund_type"]
            hex_color = FUND_COLORS.get(fund_type, "#000000")
            # Convert hex to rgba with light alpha
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            fund_rgba = f"rgba({int(hex_color[0:2], 16)}, {int(hex_color[2:4], 16)}, {int(hex_color[4:6], 16)}, 0.15)"
            green_rgba = "rgba(46, 160, 67, 0.12)"
            red_rgba = "rgba(248, 81, 73, 0.12)"
            styles = []
            for col in row.index:
                if col.startswith("_"):
                    styles.append("display: none;")
                elif col == "Fund":
                    styles.append("background-color: " + fund_rgba)
                elif col == "Net Invested (Î” vs Exp)":
                    delta_val = row.get("_delta_net_inv_disp", None)
                    if delta_val is None or delta_val == 0:
                        styles.append("")
                    elif delta_val > 0:
                        styles.append("background-color: " + green_rgba)
                    else:
                        styles.append("background-color: " + red_rgba)
                elif col == "Quantity (theor) (Î” vs Q real)":
                    delta_val = row.get("_delta_qty_disp", None)
                    if delta_val is None or delta_val == 0:
                        styles.append("")
                    elif delta_val > 0:
                        styles.append("background-color: " + green_rgba)
                    else:
                        styles.append("background-color: " + red_rgba)
                else:
                    styles.append("")
            return styles
        
        styled_df = display_df.style.apply(style_fund_rows, axis=1)
        
        # Display interactive dataframe with sorting and filtering
        st.dataframe(styled_df, width="stretch", hide_index=True, column_config={
            "Price (â‚¬)": st.column_config.NumberColumn(format="â‚¬%.2f"),
            "Fees (â‚¬)": st.column_config.NumberColumn(format="â‚¬%.2f"),
            "Gross Contribution": st.column_config.NumberColumn(format="â‚¬%.2f"),
            "_delta_net_inv_raw": None,
            "_delta_qty_raw": None,
            "_delta_net_inv_disp": None,
            "_delta_qty_disp": None,
            "_fund_type": None,
        })
        
        # CSS for smaller (Now...) text
        st.markdown("""
        <style>
        [data-testid="stMetric"] small { font-size: 0.5em !important; opacity: 0.7; }
        </style>
        """, unsafe_allow_html=True)
        
        # Totals row
        st.markdown("")
        st.markdown("**Totals (based on filters):**")
        # Calculate totals
        total_gross_theor = trans_df["Gross Contribution (theor)"].sum()
        total_net_invested = trans_df["Net Invested"].sum()
        total_fees = trans_df["Fees (â‚¬)"].sum()

        # Calculate fees percentage
        fees_pct = (total_fees / total_gross_theor * 100) if total_gross_theor > 0 else 0.0

        # P/L Price approx: sum of delta vs exp
        pl_price_approx = trans_df["Î” Net Inv vs Exp"].sum()

        # P/L Quantity approx: requires historical data
        hist_data = load_historical_prices()
        latest_date_str = "-"
        pl_qty_approx = 0.0
        pl_qty_approx_now = 0.0

        if len(hist_data) > 0 and "date" in hist_data.columns:
            # Get latest date from historical data
            latest_date = pd.to_datetime(hist_data["date"]).max()
            latest_date_str = latest_date.strftime("%Y-%m-%d") if pd.notna(latest_date) else "-"

            # For each transaction: delta_qty * row_price and delta_qty * latest_price
            for _, row in trans_df.iterrows():
                fund = row["Fund"]
                delta_qty_raw = row["Î” Quantity"]
                row_price = row["Price (â‚¬)"]
                
                # Use displayed precision for delta qty (per fund)
                dp = fund_qty_decimals.get(fund, 3)
                delta_qty = round(delta_qty_raw, dp) if pd.notna(delta_qty_raw) else None
                if delta_qty is not None and abs(delta_qty) < 10 ** (-dp):
                    delta_qty = 0.0

                if pd.notna(delta_qty):
                    # Main calculation: delta_qty * row_price
                    pl_qty_approx += delta_qty * row_price
                    
                    # Now calculation: delta_qty * latest_price
                    if fund in hist_data.columns:
                        latest_price = hist_data[hist_data["date"] == latest_date][fund].values
                        if len(latest_price) > 0 and pd.notna(latest_price[0]):
                            pl_qty_approx_now += delta_qty * latest_price[0]

        # Avg NAV (only when one fund selected)
        if len(filter_funds) == 1:
            total_quantity = trans_df["Quantity"].sum()
            total_gross_contrib = (trans_df["Quantity"] * trans_df["Price (â‚¬)"]).sum()
            avg_nav = total_gross_contrib / total_quantity if total_quantity > 0 else 0
            avg_nav_display = f"â‚¬ {avg_nav:,.2f}"
        else:
            avg_nav_display = "-"

        # Display totals in 2 rows x 3 columns
        row1_col1, row1_col2, row1_col3 = st.columns(3)
        with row1_col1:
            st.metric("Total Gross Contribution", f"â‚¬ {total_gross_theor:,.2f}")
        with row1_col2:
            st.metric("Total Net Invested", f"â‚¬ {total_net_invested:,.2f}")
        with row1_col3:
            st.metric("Fees", f"â‚¬ {total_fees:,.2f}", delta=f"{fees_pct:.2f}%", delta_color="off")

        row2_col1, row2_col2, row2_col3 = st.columns(3)
        with row2_col1:
            st.metric("P/L Price approx.", f"â‚¬ {pl_price_approx:+,.2f}")
        with row2_col2:
            pl_qty_display = f"â‚¬ {pl_qty_approx:+,.2f} (Now: â‚¬ {pl_qty_approx_now:+,.2f})" if latest_date_str != "-" else f"â‚¬ {pl_qty_approx:+,.2f}"
            st.metric(f"P/L Quantity approx. (as of {latest_date_str})", pl_qty_display)
        with row2_col3:
            st.metric("Avg NAV", avg_nav_display if avg_nav_display else "-")
    else:
        st.info("No transactions yet")

def active_funds():
    st.header("ðŸ“‹ Active Funds")
    
    if len(funds) > 0:
        # Display funds data
        display_funds = funds.copy()
        
        # Reorder columns: Fund, Ticker, ISIN, Fund Name, Type
        display_funds = display_funds[["Fund", "Ticker", "ISIN", "Fund Name", "Type"]].copy()
        
        # Add fund type column for styling
        display_funds["_fund_type"] = funds["Fund"].values
        
        # Apply color styling
        def style_fund_rows(row):
            fund_type = row["_fund_type"]
            hex_color = FUND_COLORS.get(fund_type, "#000000")
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            rgba = f"rgba({int(hex_color[0:2], 16)}, {int(hex_color[2:4], 16)}, {int(hex_color[4:6], 16)}, 0.15)"
            
            styles = []
            for col in row.index:
                if col == "Fund":
                    styles.append("background-color: " + rgba)
                elif col == "_fund_type":
                    styles.append("display: none;")
                else:
                    styles.append("")
            return styles
        
        styled_funds = display_funds.style.apply(style_fund_rows, axis=1)
        
        st.dataframe(styled_funds, width="stretch", hide_index=True, column_config={
            "_fund_type": None  # Hide the column
        })
    else:
        st.info("No funds added yet")

def historical_prices():
    st.header("ðŸ“ˆ Historical Data Charts")
    
    # Helper function to calculate y-axis range with padding
    def calculate_y_axis_range_with_padding(traces, padding_pct=0.01):
        """Calculate y-axis range with specified padding percentage."""
        all_y_values = []
        for trace in traces:
            if hasattr(trace, 'y') and trace.y is not None:
                all_y_values.extend([y for y in trace.y if y is not None])
        
        if all_y_values:
            y_min = min(all_y_values)
            y_max = max(all_y_values)
            y_range_size = y_max - y_min
            
            # Handle edge case where all values are identical
            if y_range_size == 0:
                # Use a small percentage of the value itself as padding
                padding = abs(y_min) * padding_pct if y_min != 0 else 1.0
            else:
                padding = y_range_size * padding_pct
            
            return y_min - padding, y_max + padding
        return None, None
    
    # Helper function to create price annotation
    def create_price_annotation(price, fund):
        """Create a standardized price annotation for a fund."""
        return dict(
            x=0,
            y=price,
            xref="paper",
            yref="y",
            text=f"â‚¬{price:,.2f}",
            showarrow=False,
            xanchor="right",
            xshift=-5,
            font=dict(size=9, color=FUND_COLORS.get(fund, "#999999")),
            bgcolor="rgba(255,255,255,0.8)",
            bordercolor=FUND_COLORS.get(fund, "#999999"),
            borderwidth=1,
            borderpad=2,
        )
    
    # Initialize session state for refresh
    if "force_refresh" not in st.session_state:
        st.session_state.force_refresh = False
    
    # Refresh button (reload CSV only)
    if st.button("ðŸ”„ Reload Cached Data", help="Reload historical_data.csv from disk"):
        st.session_state.force_refresh = True
        st.cache_data.clear()
        st.rerun()
    
    # Show loading message
    if st.session_state.force_refresh:
        st.info("ðŸ”„ Reloading cached CSV...")
        st.session_state.force_refresh = False
    
    with st.spinner("Loading historical price data..."):
        hist_df = load_historical_prices()
    
    if len(hist_df) == 0:
        st.error("âš ï¸ No historical data available.")
        
        # Show specific error if available
        if "last_fetch_error" in st.session_state:
            st.warning(f"**Last fetch status:** {st.session_state.last_fetch_error}")
        
        st.info("**Possible reasons:**\n- Yahoo Finance is blocking requests (rate limiting)\n- Tickers in funds.csv are incorrect or delisted\n- Network connectivity issues\n\n**To debug:**\n1. Check Streamlit Cloud logs for [INFO]/[WARN]/[ERROR] messages\n2. Verify tickers in funds.csv have '.F' suffix\n3. Try again in a few minutes if rate-limited")
        
        # Show funds.csv tickers for debugging
        with st.expander("ðŸ” Show configured tickers"):
            st.code(f"Tickers: {', '.join(yahoo_tickers)}")
        
        return
    else:
        st.success(f"âœ… Loaded {len(hist_df)} price records for {len(hist_df.columns)-1} funds")
        # Show last updated banner (data max date + file timestamp)
        try:
            max_date = pd.to_datetime(hist_df.get("date"), errors="coerce").max()
            file_ts_str = None
            if os.path.exists("historical_data.csv"):
                ts = os.path.getmtime("historical_data.csv")
                file_ts_str = datetime.utcfromtimestamp(ts).strftime("%Y-%m-%d %H:%M UTC")
            parts = []
            if pd.notna(max_date):
                parts.append(f"Last data date: {max_date.strftime('%Y-%m-%d')}")
            if file_ts_str:
                parts.append(f"File updated: {file_ts_str}")
            if parts:
                st.caption(" â€¢ ".join(parts) + " â€¢ Source: cached CSV (GitHub Actions)")
        except Exception:
            pass

    # Ensure only known funds and date
    fund_cols = [c for c in hist_df.columns if c in funds["Fund"].tolist()]
    hist_df_display = hist_df[["date"] + fund_cols].copy()
    hist_df_display["date"] = pd.to_datetime(hist_df_display["date"]) 

    # Fund filter buttons (same style as Transaction History)
    if "historical_fund_filter" not in st.session_state:
        st.session_state.historical_fund_filter = fund_cols
    if "hist_view_mode" not in st.session_state:
        st.session_state.hist_view_mode = "grid"

    if len(fund_cols) > 0:
        st.markdown("**Filter by Fund:**")
        fund_button_css = "<style>"
        for fund in fund_cols:
            hex_color = FUND_COLORS.get(fund, "#999999")
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            fund_button_css += f"""
            button[data-testid=\"baseButton-primary\"][aria-label=\"{fund}\"] {{
                background-color: rgba(200, 200, 200, 0.8) !important;
                border: none !important;
                color: rgb({r}, {g}, {b}) !important;
                font-weight: 600 !important;
            }}
            """
        fund_button_css += "</style>"
        st.markdown(fund_button_css, unsafe_allow_html=True)

        num_cols = len(fund_cols) + 1
        cols = st.columns(num_cols)
        for idx, fund in enumerate(fund_cols):
            with cols[idx]:
                is_active = fund in st.session_state.historical_fund_filter
                if st.button(fund, key=f"hist_btn_{fund}", type="primary" if is_active else "secondary", width="stretch"):
                    if is_active:
                        st.session_state.historical_fund_filter.remove(fund)
                    else:
                        st.session_state.historical_fund_filter.append(fund)
                    st.rerun()
        with cols[-1]:
            if st.button("âœ•", key="reset_hist_filters", help="Reset filters", width="stretch"):
                st.session_state.historical_fund_filter = fund_cols
                st.rerun()
        selected_funds = st.session_state.historical_fund_filter
    else:
        selected_funds = []

    # Date range filters + controls
    col1, col2, col3 = st.columns([2, 2, 1.5])
    with col1:
        min_d = hist_df_display["date"].min().date()
        # Set default start date to October 1, 2024
        default_start = date(2024, 10, 1)
        # Use the later of October 1, 2024 or the minimum date in the data
        if min_d > default_start:
            default_start = min_d
        start_d = st.date_input("Start", value=default_start, key="hist_start_date")
    with col2:
        max_d = hist_df_display["date"].max().date()
        end_d = st.date_input("End", value=max_d, key="hist_end_date")
    with col3:
        st.markdown("")
        view_label = "Combined View" if st.session_state.hist_view_mode == "combined" else "Grid View"
        use_combined = st.toggle(view_label, value=(st.session_state.hist_view_mode == "combined"), key="hist_view_toggle")
        st.session_state.hist_view_mode = "combined" if use_combined else "grid"

    plot_df = hist_df_display[(hist_df_display["date"] >= pd.to_datetime(start_d)) & (hist_df_display["date"] <= pd.to_datetime(end_d))]
    if not selected_funds:
        st.info("Select at least one fund")
        return

    # Compute average NAV per fund within selected date range (transaction history)
    avg_nav_by_fund = {}
    tx_range = transactions.copy()
    tx_range["Date"] = pd.to_datetime(tx_range.get("Date"), errors="coerce")
    tx_range = tx_range.dropna(subset=["Date"])
    tx_range = tx_range[(tx_range["Date"] >= pd.to_datetime(start_d)) & (tx_range["Date"] <= pd.to_datetime(end_d))]
    if len(tx_range) > 0:
        tx_range["Gross Contribution"] = tx_range["Quantity"] * tx_range["Price (â‚¬)"] + tx_range["Fees (â‚¬)"]
        grouped = tx_range.groupby("Fund").agg({"Gross Contribution": "sum", "Quantity": "sum"})
        for fund, row in grouped.iterrows():
            qty = row["Quantity"]
            if qty and qty != 0:
                avg_nav_by_fund[fund] = row["Gross Contribution"] / qty

    # Combined view
    if st.session_state.hist_view_mode == "combined":
        fig_combined = go.Figure()
        latest_prices = {}  # Collect latest prices for each fund
        
        for fund in selected_funds:
            fund_df = plot_df[["date", fund]].dropna().sort_values("date")
            if len(fund_df) == 0:
                continue
            
            # Get the latest price for this fund
            latest_price = fund_df[fund].iloc[-1]
            latest_prices[fund] = latest_price
            
            fig_combined.add_trace(
                go.Scatter(
                    x=fund_df["date"],
                    y=fund_df[fund],
                    mode="lines",
                    name=fund,
                    line=dict(color=FUND_COLORS.get(fund, "#999999"), width=2),
                    hovertemplate="<b>%{x|%Y-%m-%d}</b><br>â‚¬%{y:,.2f}<extra></extra>",
                )
            )

            # Average NAV line for this fund
            if fund in avg_nav_by_fund:
                fig_combined.add_trace(
                    go.Scatter(
                        x=[fund_df["date"].min(), fund_df["date"].max()],
                        y=[avg_nav_by_fund[fund], avg_nav_by_fund[fund]],
                        mode="lines",
                        name=f"{fund} Avg NAV",
                        line=dict(color=FUND_COLORS.get(fund, "#999999"), dash="dash", width=1.5),
                        hovertemplate=f"<b>{fund} Avg NAV</b><br>â‚¬%{{y:,.2f}}<extra></extra>",
                        showlegend=True,
                    )
                )
        
        # Calculate y-axis range with 1% padding
        y_axis_min, y_axis_max = calculate_y_axis_range_with_padding(fig_combined.data)

        fig_combined.update_layout(
            height=450,
            hovermode="x unified",
            xaxis_title="",
            yaxis_title="NAV (â‚¬)",
            template="plotly_white",
            legend_title="Fund",
            showlegend=False,
            dragmode="pan",
            uirevision="hist_combined",
            newshape=dict(line_color="#888888"),
        )
        fig_combined.update_xaxes(
            rangeslider=dict(visible=True, thickness=0.07),
            rangeselector=dict(
                buttons=[
                    dict(count=1, label="1M", step="month", stepmode="backward"),
                    dict(count=3, label="3M", step="month", stepmode="backward"),
                    dict(count=6, label="6M", step="month", stepmode="backward"),
                    dict(count=1, label="YTD", step="year", stepmode="todate"),
                    dict(count=1, label="1Y", step="year", stepmode="backward"),
                    dict(count=3, label="3Y", step="year", stepmode="backward"),
                    dict(step="all", label="All"),
                ]
            ),
            showspikes=True,
            spikemode="across",
            spikesnap="cursor",
            spikethickness=1,
            spikecolor="#888888",
        )
        
        # Update y-axis with padding
        yaxis_config = dict(
            rangemode="normal",
            fixedrange=False,
            showspikes=True,
            spikemode="across",
            automargin=True,
        )
        
        # Apply calculated range with padding
        if y_axis_min is not None and y_axis_max is not None:
            yaxis_config['range'] = [y_axis_min, y_axis_max]
            yaxis_config['autorange'] = False
            
            # Add annotations for latest prices on the y-axis
            for fund, price in latest_prices.items():
                fig_combined.add_annotation(**create_price_annotation(price, fund))
        else:
            yaxis_config['autorange'] = True
        
        fig_combined.update_yaxes(**yaxis_config)
        
        st.plotly_chart(
            fig_combined,
            use_container_width=True,
            config=dict(
                scrollZoom=True,
                displaylogo=False,
                doubleClick="reset",
                modeBarButtonsToAdd=[
                    "drawline",
                    "eraseshape",
                    "zoom2d",
                    "pan2d",
                    "select2d",
                    "lasso2d",
                ],
                toImageButtonOptions=dict(format="png", filename="historical_combined", height=600, width=1000, scale=2),
            ),
        )
    else:
        # Grid view: render each fund chart as its own Plotly figure
        if len(selected_funds) > 6:
            cols_per_row = 2
        else:
            cols_per_row = min(3, len(selected_funds))
        
        # Prepare transaction data for markers (filtered by date range)
        trans_df = transactions.copy()
        trans_df["Date"] = pd.to_datetime(trans_df["Date"], errors="coerce")
        trans_df = trans_df.dropna(subset=["Date"])
        trans_df = trans_df[(trans_df["Date"] >= pd.to_datetime(start_d)) & (trans_df["Date"] <= pd.to_datetime(end_d))]

        # Render charts in rows of columns
        for row_start in range(0, len(selected_funds), cols_per_row):
            row_funds = selected_funds[row_start : row_start + cols_per_row]
            cols = st.columns(len(row_funds))
            for col_slot, fund in zip(cols, row_funds):
                with col_slot:
                    fund_df = plot_df[["date", fund]].dropna().sort_values("date")
                    if len(fund_df) == 0:
                        st.info(f"No data for {fund}")
                        continue

                    # Get the latest price for this fund
                    latest_price = fund_df[fund].iloc[-1]

                    fig_fund = go.Figure()
                    # Price line
                    fig_fund.add_trace(
                        go.Scatter(
                            x=fund_df["date"],
                            y=fund_df[fund],
                            mode="lines",
                            name=fund,
                            line=dict(color=FUND_COLORS.get(fund, "#999999"), width=2),
                            hovertemplate=f"<b>{fund}</b><br>%{{x|%Y-%m-%d}}<br>â‚¬%{{y:,.2f}}<extra></extra>",
                            showlegend=False,
                        )
                    )

                    # Average NAV line
                    if fund in avg_nav_by_fund:
                        fig_fund.add_trace(
                            go.Scatter(
                                x=[fund_df["date"].min(), fund_df["date"].max()],
                                y=[avg_nav_by_fund[fund], avg_nav_by_fund[fund]],
                                mode="lines",
                                name=f"{fund} Avg NAV",
                                line=dict(color=FUND_COLORS.get(fund, "#999999"), dash="dash", width=1.5),
                                hovertemplate=f"<b>{fund} Avg NAV</b><br>â‚¬%{{y:,.2f}}<extra></extra>",
                                showlegend=False,
                            )
                        )

                    # Transaction markers
                    fund_trans = trans_df[trans_df["Fund"] == fund]
                    if len(fund_trans) > 0:
                        trans_prices = []
                        trans_dates = []
                        hover_texts = []

                        for _, trans_row in fund_trans.iterrows():
                            trans_date = trans_row["Date"]
                            closest_idx = (fund_df["date"] - trans_date).abs().idxmin()
                            trans_price = fund_df.loc[closest_idx, fund]

                            trans_prices.append(trans_price)
                            trans_dates.append(trans_date)

                            hover_text = (
                                f"<b>Transaction</b><br>"
                                f"Date: {trans_date.strftime('%Y-%m-%d')}<br>"
                                f"Quantity: {trans_row['Quantity']:.3f}<br>"
                                f"Price: â‚¬{trans_row['Price (â‚¬)']:.2f}<br>"
                                f"Fees: â‚¬{trans_row['Fees (â‚¬)']:.2f}<br>"
                                f"Total: â‚¬{(trans_row['Quantity'] * trans_row['Price (â‚¬)'] + trans_row['Fees (â‚¬)']):.2f}"
                            )
                            hover_texts.append(hover_text)

                        fig_fund.add_trace(
                            go.Scatter(
                                x=trans_dates,
                                y=trans_prices,
                                mode="markers",
                                name=f"{fund} Transactions",
                                marker=dict(
                                    size=10,
                                    color=FUND_COLORS.get(fund, "#999999"),
                                    symbol="circle",
                                    line=dict(width=2, color="white")
                                ),
                                hovertemplate="%{text}<extra></extra>",
                                text=hover_texts,
                                showlegend=False,
                            )
                        )

                    # Calculate y-axis range with 1% padding
                    y_axis_min, y_axis_max = calculate_y_axis_range_with_padding(fig_fund.data)

                    fig_fund.update_layout(
                        height=320,
                        hovermode="x unified",
                        template="plotly_white",
                        legend_title="",
                        showlegend=False,
                        margin=dict(t=40, b=30, l=10, r=10),
                        dragmode="pan",
                        # Use shared uirevision to maintain zoom/pan state across Streamlit reruns.
                        # Note: Streamlit + Plotly don't support real-time synchronization between
                        # different chart instances. Users can manually apply the same time range to
                        # all charts using the range selector buttons (1M, 3M, 6M, etc.) on each chart.
                        uirevision=f"hist_grid_sync",
                        newshape=dict(line_color="#888888"),
                    )
                    
                    # Configure x-axis
                    xaxis_config = dict(
                        title_text="",
                        rangeslider=dict(visible=True, thickness=0.07),
                        rangeselector=dict(
                            buttons=[
                                dict(count=1, label="1M", step="month", stepmode="backward"),
                                dict(count=3, label="3M", step="month", stepmode="backward"),
                                dict(count=6, label="6M", step="month", stepmode="backward"),
                                dict(count=1, label="YTD", step="year", stepmode="todate"),
                                dict(count=1, label="1Y", step="year", stepmode="backward"),
                                dict(count=3, label="3Y", step="year", stepmode="backward"),
                                dict(step="all", label="All"),
                            ]
                        ),
                        showspikes=True,
                        spikemode="across",
                        spikesnap="cursor",
                        spikethickness=1,
                        spikecolor="#888888",
                    )
                    
                    fig_fund.update_xaxes(**xaxis_config)
                    
                    # Update y-axis with padding
                    yaxis_config = dict(
                        title_text="NAV (â‚¬)",
                        rangemode="normal",
                        fixedrange=False,
                        showspikes=True,
                        spikemode="across",
                        automargin=True,
                    )
                    
                    # Apply calculated range with padding
                    if y_axis_min is not None and y_axis_max is not None:
                        yaxis_config['range'] = [y_axis_min, y_axis_max]
                        yaxis_config['autorange'] = False
                        
                        # Add annotation for latest price on the y-axis
                        fig_fund.add_annotation(**create_price_annotation(latest_price, fund))
                    else:
                        yaxis_config['autorange'] = True
                    
                    fig_fund.update_yaxes(**yaxis_config)
                    
                    st.plotly_chart(
                        fig_fund,
                        use_container_width=True,
                        config=dict(
                            scrollZoom=True,
                            displaylogo=False,
                            doubleClick="reset",
                            modeBarButtonsToAdd=[
                                "drawline",
                                "eraseshape",
                                "zoom2d",
                                "pan2d",
                                "select2d",
                                "lasso2d",
                            ],
                            toImageButtonOptions=dict(format="png", filename=f"historical_{fund}", height=600, width=1000, scale=2),
                        ),
                    )

    # Single-row unified legend placed under the last chart
    legend_row_html = "<div style='display:flex; flex-wrap:nowrap; gap:18px; align-items:center; overflow-x:auto; padding:8px 0; border-top:1px solid rgba(150,150,150,.2);'>"
    # Shapes
    legend_row_html += "<div><span style='display:inline-block;width:22px;height:0;border-top:3px solid #888;vertical-align:middle;margin-right:6px;'></span>NAV</div>"
    legend_row_html += "<div><span style='display:inline-block;width:22px;height:0;border-top:3px dashed #888;vertical-align:middle;margin-right:6px;'></span>Avg NAV</div>"
    legend_row_html += "<div><span style='display:inline-block;width:10px;height:10px;border-radius:50%;background:#888;margin-right:6px;border:2px solid #fff;vertical-align:middle;'></span>Transaction</div>"
    # Fund swatches
    for f in selected_funds:
        color = FUND_COLORS.get(f, "#999999")
        legend_row_html += f"<div><span style='display:inline-block;width:12px;height:12px;border-radius:2px;background:{color};border:1px solid rgba(0,0,0,.3);margin-right:6px;vertical-align:middle;'></span>{f}</div>"
    legend_row_html += "</div>"
    st.markdown(legend_row_html, unsafe_allow_html=True)

    # Historical Data Table with colored headers
    st.divider()
    st.subheader("ðŸ“Š Historical Data")
    
    # Prepare table: selected funds with most recent dates first
    historical_data_df = hist_df_display[["date"] + selected_funds].copy() if selected_funds else pd.DataFrame()
    historical_data_df["date"] = pd.to_datetime(historical_data_df["date"])
    historical_data_df = historical_data_df.sort_values("date", ascending=False).reset_index(drop=True)
    
    if len(historical_data_df) > 0:
        # Format dates as YYYY-MM-DD
        historical_data_df["date"] = historical_data_df["date"].dt.strftime("%Y-%m-%d")
        
        # Build CSS for colored headers based on fund colors
        header_css = "<style>\n"
        header_css += "table th { font-weight: 600 !important; }\n"
        header_css += "table th:first-child { background-color: rgba(100, 100, 100, 0.3) !important; }\n"
        for idx, fund_name in enumerate(selected_funds, start=1):
            hex_color = FUND_COLORS.get(fund_name, "#999999")
            if hex_color.startswith('#'):
                hex_color = hex_color[1:]
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            header_css += f"table th:nth-child({idx+1}) {{ background-color: rgba({r}, {g}, {b}, 0.3) !important; }}\n"
        header_css += "</style>\n"
        st.markdown(header_css, unsafe_allow_html=True)
        
        # Display formatted table
        st.dataframe(historical_data_df, width="stretch", hide_index=True,
                     column_config={col: st.column_config.NumberColumn(format="â‚¬%.2f") for col in selected_funds})
    else:
        st.info("No historical data to display")

def add_transactions_and_funds():
    global funds, transactions
    
    # ---------- AUTHENTICATION ----------
    st.subheader("ðŸ” Authentication")
    if not st.session_state.authenticated:
        pwd = st.text_input("Enter password to edit data:", type="password")
        if pwd == OWNER_PASSWORD:
            st.session_state.authenticated = True
            st.rerun()
        elif pwd:
            st.error("Incorrect password")
        st.info("Enter password to add transactions and funds")
        return
    
    IS_OWNER = st.session_state.authenticated
    
    st.header("ðŸ’° Add Transaction")
    if len(funds) == 0:
        st.info("Add a fund first")
    else:
        if IS_OWNER:
            with st.form("add_Transaction"):
                fund_choice = st.selectbox("Fund", funds["Fund"].tolist()) 
                contrib_date = st.date_input("Date", date.today())
                price = st.number_input("Price (â‚¬)", min_value=0.0)
                quantity = st.number_input("Quantity", min_value=0.0, step=0.001, format="%f")
                fees = st.number_input("Fees (â‚¬)", min_value=0.0)
                submitted_c = st.form_submit_button("Add Transaction")
                if submitted_c:
                    if quantity <= 0 or price <= 0:
                        st.error("Quantity and Price must be greater than 0")
                    else:
                        new_contrib = pd.DataFrame([{
                            "Date": contrib_date.strftime("%Y-%m-%d"),
                            "Fund": fund_choice,
                            "Price (â‚¬)": price,
                            "Quantity": quantity,
                            "Fees (â‚¬)": fees,
                        }])
                        transactions = pd.concat([transactions, new_contrib], ignore_index=True)
                        transactions.to_csv(TRANSACTIONS_FILE, index=False)
                        st.success("Transaction added")
                        st.rerun()
        else:
            st.info("Viewer mode (read-only)")

    st.divider()

    st.header("âž• Add Fund")

    if IS_OWNER:
        with st.form("add_fund"):
            fund_cat = st.text_input("Fund", placeholder="e.g., US, EU, EM, Tech")
            
            col1, col2 = st.columns(2)
            with col1:
                isin = st.text_input("ISIN", placeholder="e.g., LU0281484963")
                name = st.text_input(
                    "Fund Name",
                    placeholder="e.g., JPMorgan Funds - US Select Equity Plus Fund D (acc) - EUR"
                )
                fund_type = st.selectbox("Type", ["Equity", "Bond"])
            with col2:
                ticker = st.text_input("Ticker", placeholder="e.g., 0P0001CRXW")
                colour = st.color_picker("Colour", value="#C00000")
            
            submitted = st.form_submit_button("Add Fund")
            if submitted:
                if not fund_cat.strip() or not isin.strip() or not ticker.strip() or not name.strip():
                    st.error("All fields are required")
                elif fund_cat in funds["Fund"].values:
                    st.error(f"Fund '{fund_cat}' already exists")
                elif isin in funds["ISIN"].values:
                    st.error(f"ISIN '{isin}' already exists")
                elif ticker in funds["Ticker"].values:
                    st.error(f"Ticker '{ticker}' already exists")
                else:
                    new_fund = pd.DataFrame([{
                        "Fund": fund_cat,
                        "Ticker": ticker,
                        "ISIN": isin,
                        "Fund Name": name,
                        "Type": fund_type,
                        "Colour": colour,
                    }])
                    funds = pd.concat([funds, new_fund], ignore_index=True)
                    # Save locally first for immediate app state
                    funds.to_csv(FUNDS_FILE, index=False)

                    # Attempt to push to GitHub repository
                    try:
                        csv_str = funds.to_csv(index=False)
                        if GITHUB_TOKEN and GITHUB_REPO:
                            ok = github_put_file(
                                path=FUNDS_FILE,
                                content_str=csv_str,
                                message=f"Add/Update fund '{fund_cat}' via Streamlit",
                            )
                            if ok:
                                st.success("Fund added and pushed to GitHub. GitHub Actions will refresh prices shortly.")
                            else:
                                st.warning("Fund saved locally but push to GitHub failed. Please check token/permissions.")
                        else:
                            st.warning("Fund saved locally. To sync to GitHub, configure GITHUB_TOKEN and GITHUB_REPO in Streamlit secrets.")
                    except Exception as e:
                        st.warning(f"Fund saved locally, but push failed: {e}")

                    st.rerun()


# Initialize theme state
if "theme_dark" not in st.session_state:
    st.session_state.theme_dark = True

# Navigation setup
pg = st.navigation({
    "Sbronze Menu": [
        st.Page(overview_and_charts, title="ðŸ“Š Overview & Charts"),
        st.Page(transaction_history, title="ðŸ“œ Transaction History"),
        st.Page(historical_prices, title="ðŸ“ˆ Historical Data Charts"),
        st.Page(active_funds, title="ðŸ“‹ Active Funds"),
        st.Page(add_transactions_and_funds, title="âž• Add Transactions & Funds"),
    ]
})


# Custom CSS for navigation styling
st.markdown("""
<style>
    /* Style navigation items */
    div[data-testid="stSidebarNav"] ul {
        padding: 0;
    }
    
    div[data-testid="stSidebarNav"] li {
        margin: 0.3rem 0;
    }
    
    div[data-testid="stSidebarNav"] a {
        padding: 0.85rem 1rem !important;
        border-radius: 0.5rem !important;
        color: rgba(150, 150, 150, 0.75) !important;
        font-size: 0.95rem !important;
        font-weight: 400 !important;
        text-decoration: none !important;
    }
    
    div[data-testid="stSidebarNav"] a:hover {
        background-color: rgba(255, 255, 255, 0.05) !important;
        color: rgba(180, 180, 180, 0.9) !important;
    }
    
    div[data-testid="stSidebarNav"] a[aria-current="page"] {
        background-color: rgba(255, 255, 255, 0.12) !important;
        color: rgba(255, 255, 255, 1) !important;
        font-size: 1.05rem !important;
        font-weight: 700 !important;
    }
    
    /* Style filter buttons with fund colors - text color will be overridden by fund-specific CSS */
    button[kind="primary"] {
        background-color: rgba(200, 215, 200, 0.8) !important;
        color: rgba(30, 30, 30, 1) !important;
        font-weight: 600 !important;
        border: none !important;
    }
    
    /* Reset button styling */
    button[aria-label="âœ•"][kind="secondary"] {
        background-color: rgba(30, 30, 30, 0.9) !important;
        color: rgba(150, 150, 150, 0.8) !important;
        border: none !important;
    }
    
    button[kind="secondary"] {
        background-color: rgba(40, 40, 40, 0.9) !important;
        color: rgba(200, 50, 50, 0.8) !important;
        border: none !important;
    }
</style>
""", unsafe_allow_html=True)

pg.run()
